<?php


namespace App\Normalizer;


use Doctrine\Common\Collections\Collection;
use Doctrine\ORM\EntityManagerInterface;
use Symfony\Component\PropertyAccess\PropertyAccessorInterface;
use Symfony\Component\PropertyInfo\PropertyTypeExtractorInterface;
use Symfony\Component\Serializer\Mapping\Factory\ClassMetadataFactoryInterface;
use Symfony\Component\Serializer\NameConverter\NameConverterInterface;
use Symfony\Component\Serializer\Normalizer\AbstractNormalizer;
use Symfony\Component\Serializer\Normalizer\ObjectNormalizer;

class EntityNormalizer extends ObjectNormalizer
{
    /**
     * Entity manager
     * @var EntityManagerInterface
     */
    protected $em;

    /**
     * Entity normalizer
     * @param EntityManagerInterface $em
     * @param ClassMetadataFactoryInterface|null $classMetadataFactory
     * @param NameConverterInterface|null $nameConverter
     * @param PropertyAccessorInterface|null $propertyAccessor
     * @param PropertyTypeExtractorInterface|null $propertyTypeExtractor
     */
    public function __construct(
        EntityManagerInterface $em,
        ?ClassMetadataFactoryInterface $classMetadataFactory = null,
        ?NameConverterInterface $nameConverter = null,
        ?PropertyAccessorInterface $propertyAccessor = null,
        ?PropertyTypeExtractorInterface $propertyTypeExtractor = null
    ) {
        parent::__construct($classMetadataFactory, $nameConverter, $propertyAccessor, $propertyTypeExtractor);

        // Entity manager
        $this->em = $em;
    }

    /**
     * @inheritDoc
     */
    public function supportsDenormalization($data, $type, $format = null)
    {
//        die(var_dump('test'));
        return $this->em->getMetadataFactory()->hasMetadataFor($type) && (is_numeric($data) || is_string($data));
    }

    /**
     * @inheritDoc
     */
    public function denormalize($data, $class, $format = null, array $context = [])
    {
        return $this->em->find($class, $data);
    }

    public function supportsNormalization($data, string $format = null)
    {
        return is_object($data) && $this->em->getMetadataFactory()->hasMetadataFor(get_class($data)) && parent::supportsNormalization($data, $format);


//        return parent::supportsNormalization($data, $format); // TODO: Change the autogenerated stub
    }

    public function normalize($object, string $format = null, array $context = [])
    {
        $parentCallback = function ($innerObject) {
            return is_object($innerObject) && $innerObject->getId() ? $innerObject->getId() : null;
        };

        $childrenCallback = function ($innerObject) {
            if ($innerObject instanceof Collection) {
                return $innerObject->map(function ($obj) {
                    return $obj->getId();
                });
            } else {
                return array_map(function ($obj) {
                    return $obj->getId();
                }, $innerObject);
            }
        };

        $metadata = $this->em->getMetadataFactory()->getMetadataFor(get_class($object));

        $fields = isset($context[AbstractNormalizer::CALLBACKS]) ? $context[AbstractNormalizer::CALLBACKS] : [];
        foreach ($metadata->getAssociationNames() as $name) {
            if (is_array($this->propertyAccessor->getValue($object, $name)) || $this->propertyAccessor->getValue($object, $name) instanceof Collection) {
                $fields[$name] = $childrenCallback;
            } else {
                $fields[$name] = $parentCallback;
            }
        }
        $context[AbstractNormalizer::CALLBACKS] = $fields;

        return parent::normalize($object, $format, $context);
    }
}